<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <base href="../../../" />
    <script src="list.js"></script>
    <script src="page.js"></script>
    <link type="text/css" rel="stylesheet" href="page.css" />
</head>

<body>
    <h1>[name]</h1>

    <p>
        Одним из важных аспектов повышения производительности и предотвращения утечек памяти в вашем приложении является избавление от неиспользуемых библиотечных объектов.. Всякий раз, когда вы создаете экземпляр типа * three.js *, вы выделяете определенный
        объем памяти. Тем не менее, * three.js * создает для конкретных объектов например, геометрии или материалы, связанные с WebGL, такие как буферы или шейдерные программы, необходимые для рендеринга. Важно подчеркните, что эти объекты не освобождаются
        автоматически. Вместо этого приложение должно использовать специальный API для освобождения таких ресурсов.. В этом руководстве представлен краткий обзор того, как этот API используется и какие объекты актуальны в этом контексте.
    </p>

    <h2>Геометрия</h2>

    <p>
        Геометрия обычно представляет информацию вершины, определенную как набор атрибутов. *three.js* внутренне создает объект типа [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer WebGLBuffer] для каждого атрибута. Эти объекты удаляются только
        при вызове [page: BufferGeometry.dispose] (). Если геометрия устарела в вашем приложении, выполните метод, чтобы освободить все связанные ресурсы.
    </p>

    <h2>Материалы</h2>

    <p>
        Материал определяет способ визуализации объектов. * three.js * использует информацию определения материала для создания шейдерной программы для рендеринга. Шейдерные программы могут быть удалены только при утилизации соответствующего материала. Из соображений
        производительности * three.js * пытается повторно использовать существующие шейдерные программы, если это возможно. Таким образом, шейдерная программа удаляется только в том случае, если удаляются все связанные материалы. Вы можете указать удаление
        материала, выполнив [page:Material.dispose]().
    </p>

    <h2>Текстуры</h2>

    <p>
        Утилизация материала не влияет на текстуры. Они обрабатываются отдельно, так как одна текстура может использоваться несколькими материалами одновременно. Всякий раз, когда вы создаете экземпляр [page:Texture], three.js внутренне создает экземпляр [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture
        WebGLTexture]. Подобно буферам, этот объект может быть удален только путем вызова [page:Texture.dispose]().
    </p>

    <h2>Рендер цели</h2>

    <p>
        Объекты типа [page:WebGLRenderTarget] не только выделить экземпляр [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture WebGLTexture] но также [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer WebGLFramebuffer]s и
        [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer WebGLRenderbuffer] для реализации пользовательских направлений рендеринга. Эти объекты освобождаются только при выполнении [page:WebGLRenderTarget.dispose]().
    </p>

    <h2>Сцены</h2>

    <p>
        Рендерер поддерживает для сцен специальные структуры данных для сортировки и рендеринга. Если по каким-либо причинам объект сцены становится устаревшим в приложении, вызовите [page:Scene.dispose]() для того, чтобы освободить эти ресурсы.
    </p>

    <h2>Разное</h2>

    <p>
        Есть другие классы из каталога примеров, такие чтобы удалить внутренние прослушиватели событий или визуализировать целикак элементы управления или этапы постобработки, которые предоставляют *dispose()* методы . В общем, рекомендуется проверить API или
        документацию класса и следить за *dispose()*. Если есть, используйте его при уборке.
    </p>

    <h2>FAQ</h2>

    <h3>Почему * three.js * не может автоматически удалять объекты?</h3>

    <p>
        Этот вопрос много раз задавался сообществом, поэтому важно прояснить этот вопрос. Фактом является то, что * three.js * не знает времени жизни или области действия созданных пользователем объектов, таких как геометрия или материалы. Это ответственность
        приложения. Например, даже если материал в настоящее время не используется для рендеринга, он может быть необходим для следующего кадра. Таким образом, если приложение решает, что определенный объект может быть удален, оно должно уведомить механизм,
        вызвав соответствующий метод * dispose () *.
    </p>

    <h3>Удаляется ли вместе с мешем со сцены также и его геометрия и материал?</h3>

    <p>
        Нет, вы должны явно удалить геометрию и материал с помощью * dispose () *. Помните, что геометрия и материалы могут быть общими для трехмерных объектов, таких как сетки.
    </p>

    <h3>Предоставляет ли * three.js * информацию о количестве кэшированных объектов?</h3>

    <p>
        Да. Можно оценить [page: WebGLRenderer.info], специальное свойство средства визуализации с серией статистической информации о памяти графической платы и процессе рендеринга. Среди прочего, он говорит, что у вас есть много текстур, геометрии и шейдерных
        программ, которые хранятся внутри. Если вы замечаете проблемы с производительностью в приложении, рекомендуется отладить это свойство, чтобы легко определить утечку памяти.
    </p>

    <p>
        Внутренние ресурсы для текстуры выделяются, только если изображение полностью загружено. Если вы располагаете текстуру до загрузки изображения, Ничего не произошло. Ресурсы не были выделены, поэтому нет необходимости в очистке.
    </p>

    <h3>Что происходит, когда вы вызываете *dispose()* на текстуру, но изображение еще не загружено?</h3>

    <p>
        Внутренние ресурсы для текстуры выделяются, только если изображение полностью загружено. Если вы располагаете текстуру до загрузки изображения, Ничего не произошло. Ресурсы не были выделены, поэтому нет необходимости в очистке.
    </p>

    <h3>Что происходит, когда я вызываю * dispose () *, а затем использую соответствующий объект позже?</h3>

    <p>
        Удаленные внутренние ресурсы будут снова созданы движком. Таким образом, ошибки во время выполнения не произойдет, но вы можете заметить негативное влияние на производительность текущего кадра, особенно когда нужно скомпилировать шейдерные программы.
    </p>

    <h3>Как мне управлять объектами * three.js * в моем приложении? Когда я знаю, как распоряжаться вещами?</h3>

    <p>
        В целом, нет определенных рекомендаций для этого. Это сильно зависит от конкретного случая использования, когда лучше вызывать *dispose()*. Важно подчеркнуть, что не всегда необходимо утилизировать объекты постоянно. Хороший пример         это игра, которая
        состоит из нескольких уровней. Хорошее место для утилизации объекта - при переключении уровня. Приложение может пройти через старую сцену и избавиться от всех устаревших материалов, геометрий и текстур. Как уже упоминалось в предыдущем         разделе,
        он не выдает ошибку времени выполнения, если вы располагаете объект, который на самом деле все еще используется. Худшее, что может случиться, это падение производительности для одного кадра..
    </p>

    <h2>Примеры, которые демонстрируют использование dispose()</h2>

    <p>
        [example:webgl_test_memory WebGL / test / memory]<br /> [example:webgl_test_memory2 WebGL / test / memory2]<br />
    </p>

</body>

</html>